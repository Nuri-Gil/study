-- 어노테이션, 의존성
어노테이션 적용하려면 반드시 코드가 있어야 함
외부 라이브러리를 가져다 쓸 경우는 코드가 없으므로 설정을 해줘야 함
xml 혹은 java 설정을 해야 하는데 xml 은 스프링, java 는 부트에서 설정

-- 파라미터 수집과 변환
파라미터를 수집할 때는 2가지 방식이 있음
1. DTO 로 바로 수집하기
2. RequestParam 으로 수집하기 http://localhost:8080/sample/ex1?name=이름&age=30 같은 직접 GET 방식으로!

-- MODEL 이란?
Controller 에서 JSP 로 전달하는 데이터
마트에서 "컨트롤러" 가 "모델" 이라는 카트에 데이터를 담음 -> addAttribute
"모델" 에 들어간 데이터를 JSP 의 ${변수 및 객체 등등} 에 전달함
기존 코딩에서는 상속, 인터페이스를 이용하지만
Spring MVC 에서는 어노테이션을 이용함!! -> 파라미터에 추가만 해주면 됨

Model 타입의 addAttribute 메소드 -> 스프링 MVC에서 컨트롤러에서 뷰로 데이터를 전달하는 데 사용

기능과 목적
데이터 전달: addAttribute 메소드는 컨트롤러에서 뷰로 데이터를 전달하기 위해 사용
컨트롤러에서 처리한 결과나 사용자에게 보여줄 데이터를 모델에 추가하면, 이 데이터는 뷰(JSP, Thymeleaf 등)에서 사용 가능

키-값 쌍 추가: 메소드는 데이터를 키-값 쌍으로 추가
즉, 데이터는 특정 이름(키)으로 식별되며, 이 이름을 사용하여 뷰에서 데이터를 참조할 수 있음

다양한 데이터 타입 지원: addAttribute 는 객체부터 기본 자료형까지 다양한 데이터 타입을 지원
단순한 문자열부터 복잡한 객체, 리스트, 맵 등을 모델에 추가할 수 있습니다.

주요 용도
뷰에 데이터 전달: 주로 컨트롤러가 처리한 비즈니스 로직의 결과를 뷰로 전달할 때 사용
검색 결과, 사용자 정보, 화면에 표시할 목록 등을 모델에 추가하여 뷰에서 활용

동적 컨텐츠 생성: 클라이언트의 요청에 따라 동적으로 생성된 데이터를 뷰로 전달할 때 유용
사용자가 입력한 데이터를 처리한 후 그 결과를 뷰에 보여주는 경우에 addAttribute 를 사용하여 데이터를 전달

템플릿 엔진과의 호환성: 다양한 템플릿 엔진(예: JSP, Thymeleaf)에서 모델 데이터를 동일한 방식으로 접근할 수 있도록 지원


----- 09.07
SampleController 의 RedirectAttribute 부터 확인 할 것
ex00.controller.advice 의 CommonExceptionAdvice 클래스, views 의 error_page.jsp 확인할 것

-- Controller 의 리턴 타입
어노테이션 베이스가 되면 파라미터가 유연해짐
리턴 타입 역시 유연해짐 -> 고정값이 아님, 오버라이딩 개념이 아니기 때문
void -> 메서드의 호출 경로와 동일한 뷰
String -> 지정된 뷰
VO/DTO -> Ajax 를 이용해서 결과 데이터 자체를 전송할 경우, 자바 객체 타입 (Jackson-databind 같은 라이브러리 필요)
ResponseEntity<> -> HTTP 헤더 메시지와 내용물을 같이 전송 -> 그림 등의 데이터를 보낼 때 HTTP 의 Content-Type 과 데이터(바디)를 같이 보내는 등

Model/ModelAndView -> 스프링 1, 2 버전의 리턴 타입 (XXX)
HttpHeaders -> HTTP 헤더 메시지만 전송할 경우 (XXX)

-- 예외 처리
ControllerAdvice -> 컨트롤러에 문제가 생겼을 때 대신 처리해주는 기능을 빼놓은 것 (예외를 던지는 기능)
@ExceptionHandler (예외 클래스)
JSP 에서는 Model 에 전달한 객체 사용 가능

개발 영역 구분 -> 티어

{영속 영역} 테스트를 하는것을 권장
    DB SQL 문 -> MyBatis 의 Mapper.xml ->

{서비스 계층} 테스트가 옵션
    서비스 계층 ->

{컨트롤러}
    컨트롤러 ->

{뷰}
    jsp (결과데이터 출력 + 자바스크립트 핸들링)


--웹 에서 가장 먼저 시작하는 것 (책이랑 다름!)
/board/list 경로에서 시작 (GET) -> 화면에는 게시물의 리스트가 나옴
클릭등의 액션으로 /board/register(GET) -> 입력할 수 있는 내용이 나옴
-> 눌러서 등록하는 것은 POST 처리(BoardController 가 처리)
-> list 로 돌아가도록 (Redirect, GET 만 가능한 방식)
-> Post-Redirect-Get, PRG 패턴

board/list 대신 board/get/번호 (GET) 로 돌아가도록 (요즘에는 조회를 분리시키기 때문, 댓글 등의 조회를 처리하기 위해)
-> 조회가 끝나면 수정(/modify/번호), 삭제(/delete/번호) 로 가도록
-> 수정과 삭제가 끝나면 컨트롤러(BoardController) 가 수정과 삭제 처리를 하도록
-> 컨트롤러의 작업이 끝나면 조회 페이지로 다시 가도록 구현, 삭제를 하면 리스트로 가도록

github.com/ckck24/spring2024_part3

MariaDB 는 시퀀스를 사용하지 않아서 데이터가 들어가야지 번호가 생김

----- 10.07
-- Spring WEB 계층 처리
문법은 찾아서 할 수 있으나 단계를 건너뛰고 하지 말 것
접근 순서
URL(URI) 설계 -> Method (Get/Post) -> Query String/Params -> Controller -> Method -> VIEW

URL 설계 -> GET 혹은 Post -> 데이터를 던져서 숫자 등을 받아서 할것인가 혹은 ? 를 이용한 파라미터식(QueryString) 으로 할것인가
숫자 -> @PathVariable

-- Postman 프로그램 -> 브라우저에서 데이터를 보내는것을 흉내내서 테스트 가능
GET 방식의 경우에는 브라우저에서 바로 데이터를 보낼 수 있지만 POST 방식은 못보냄
POST 로 보낼 때 매번 화면에서 입력하는것을 대체해서 시도하기 위해 (REST Client Program) -> REST API 테스트용
JUNIT 테스트를 건너뛰고 컨트롤러 개발 후 Postman 혹은 브라우저에서 동작 확인 후 JSP 개발

-- @PathVariable
게시판의 글을 읽는 /board/read/9 등의 경로에서 /read 뒤에 붙는 bno 에 따라 번호를 넣을 때 동적 변수처리를 할 수 있도록 하는 어노테이션
페이지 번호처럼 수정과 삭제등의 이유로 매번 바뀔 수 있는 변수는 QueryString 처럼 ? 로 받아 처리하는게 고정화 됨

/board/modify/번호 -> /board/read/번호 에서 수정 버튼을 누르면 화면이 수정으로 이동하도록
이동은 GET 방식, 수정과 삭제를 누르면 POST 방식으로 Controller 가 처리를 하고 원하는 페이지로 Redirection 할 수 있도록

-- 실제 처리는 POST 방식
PRG 패턴 -> Post, Redirect, Get
화면을 만들어서 Post 방식으로 보내면 처리가 됨. 처리를 하고 JSP 등을 사용해 결과를 받았다고 치자 (Redirect 없이)
이러면 브라우저에서 새로고침을 할 수 있는데 이렇게 되면 주소에 있는 정보를 다시 보냄 -> 도배가 생길 수 있음
이 흐름을 끊기 위해서 새로운 Location 을 지정해서 새로운 정보를 받아 Redirect 된 서버를 호출해서 결과를 받음
이렇게 되면 새로고침을 해도 Location 이 변경되었기 때문에 그 정보만 받아오게 됨
Redirect 가 없다면??? -> 도배 발생

브라우저는 Post 방식으로 전환을 할 수 없어서 Postman 같은 Rest Client 프로그램을 사용

-- INCLUDE 관련
src/main/resources/static 에 view 관련 파일을 넣는다
대부분 이 파일들을 보기 위한 view 설정은 webapp 설정에 가있는 경우가 많다
Spring 의 경우 web.xml 의 설정이 (servlet-mapping) "/" 인데 "/" 로 들어오면 appServlet 이 동작하게 함
나머지 데이터를 처리하기 위해서는 새로운 설정을 잡아줘야 함 (servlet-context.xml, mvc:resources 설정)

static 에 있는 css 등의 파일의 경로 요청이 /board 로 되어있지 않음
절대경로에 맞추어 개발할 것 (/ 로 시작)

index.html 을 list.jsp 에 넣어뒀는데 매번 이 코드 전체를 불러서 처리하는것은 효율적이지 못함
include 폴더로 쪼개서 쓰는것이 효율적임

-- JS 추가 공간 설정
요즘에는 JS 를 아래쪽에 둠 (옛날에는 위에 둠)
JS 는 순차적으로 실행되기 때문에 Header, Body, Footer (특히 Footer)의 JS 가 로딩이 먼저 된 다음 작동하게 해야 함
Footer 에는 </body>, </html> 등으로 html 을 끝내리게 되어 BODY 에 들어갈 JS 를 읽지 못함
해결 방법은
1. Footer 에 있는 JS 를 Header 에 갖다놓음
2. 새로 Include 를 할 수 있는 JSP 를 만들어서 Footer 의 html 닫는 코드만 따로 넣고 BODY 에서 한번 더 Include 함

2번 으로 진행하면 BODY 의 코드가 약간 더 지저분해지긴 하지만 Footer 의 JS 뒤에 직접 개발하는 JS 를 넣을 수 있음
기존의 템플릿도 깨지 않을 수 있음

-- /board/list 개발 완성
실제로 JSP 와 결합을 할만한 데이터를 만들어보자
화면의 모양이 제대로 나오는지 확인하고 데이터를 뿌리자

-- JSTL (list.jsp 에서 처음 사용)
데이터 컬럼 수(th) 는 DB 컬럼과 맞춰주고 데이터 한 건당 For Loop 가 돌아야 함 (JSTL 필요)
1. JSP 표준라이브러리(JSP Standard Tag Library) 이다.
2. JSP에서 (반복과 조건, 데이타 관리 포맷, XML 조작, 데이타베이스 액세스)을 구현하는 커스텀 태그 라이브러리 모음이다.
3. 시간, 날짜, 숫자의 포맷이나 문자열 가공등의 처리에서 비즈니스로직과 프리젠테이션 로직을 분리할 수 있게 해준다.
4. JSTL은 EL(Expression Language)를 사용하여 표현한다.
https://yunamom.tistory.com/179 참조

-- 게시물 등록화면과 처리
<form> 태그 안에 액션과 메서드 지정 후 인풋 태그를 넣는다 (Register 는 POST 방식 주의)
bootstrap input 검색하면 input 태그에 대한 설명과 예제가 많음, 참조할 것!!

-- 모달 (MODAL)
경고창 같은 Alert 는 매우 위험하다 -> JS 와 브라우저의 동작 자체가 멈추기 때문
JQuery 를 더이상 쓰지 않는 추세이기 때문에 결과는 Modal 로 보내는 것이 바람직함

-- 게시물 조회
@PathVariable 을 사용해서 경로 뒤에 변수처럼 동적으로 변하는 값을 줄 수 있도록 함
URI 는 유일무이한 유니크 주소가 되어 어떤 상황과 상관 없이 같은 컨텐츠를 나타냄
예전에는 /read?bno=번호 등으로 처리했으나 요즘에는 아무도 사용하지 않음
가변적인 결과 (오늘의 1페이지가 내일 1페이지가 아니므로) 를 위해서는 사용할 수 있으나 잘 사용하지 않음
고정적인 결과 (특정 컨텐츠) 를 동일하게 나타내기 위해서는 @PathVariable 사용할 것!
조회는 GET 방식으로 함

-- 게시물 수정/삭제
GET 방식으로(화면을 보기 때문) 조회 (/board/modify/번호) -> 화면에 들어가면 목록, 수정, 삭제 버튼이 필요함
Delete 의 경우에는 Post 방식으로 bno 를 보내서 처리
Modify 의 경우에는 번호, 변경될 제목, 내용 을 Post 로 보냄 (Get 으로 다시 조회할 수 있게도 가능)
modify 후에는 /board/read/번호, remove 를 한 뒤에는 /board/list 로 갈 수 있도록

Modify 와 Delete 는 <form> 태그의 action 이 달라짐
modify.jsp 에서 card-body 내부에서 <form> 으로 데이터를 받아와야 하는데 name 이 없는 태그(input) 은 폼으로 전송되지 않음

-- 수정, 삭제 구현
삭제라는 개념은 없다! Soft Delete 개념만 있을 뿐
Soft Delete -> 논리적 삭제, Hard Delete -> 물리적 삭제
남이 남긴 댓글등의 처리는 list 에서 보이지 않게 할 수도, 삭제 메세지 등으로 치환할 수 있다

-- MyBatis 페이지 처리
Criteria 를 이용해서 BoardService, BoardController 연동해보기

Criteria 처럼 자바 클래스로 만들었을 때의 장점 -> 파라미터를 자동으로 수집할 수 있음
예전에는 @RequestGetParam 을 사용했지만 이제는 Criteria 등으로 처리할 수 있음
Default 값을 설정할 수 있어서 파라미터가 없을 때도 대비할 수 있고, 잘못되었을 경우 음수의 값도 처리할 수 있음
이렇게 데이터를 수집하는 것을 DTO (Data Transfer Object) 라고 함

컨트롤러 -> 서비스 -> Mapper -> JSP (Model 사용)
모델에는 BoardVO 의 List 와 @ModelAttribute 를 사용한 값이 필요함
@ModelAttribute 사용하지 않아도 Bean 의 형태로 자바 객체선언이 되면 모델에 전달이 되지만 명시적 이용을 위해 씀

----- MyBatis 의 Mapper 클래스와 Mapper XML 의 관계 및 동작 구조
Mapper 클래스
Mapper 클래스는 Java 인터페이스로, SQL 쿼리를 정의하고 이를 실행하기 위한 메소드를 포함합니다.
Mapper 클래스의 각 메소드는 실제로 실행할 SQL 쿼리를 지정하며, 이를 MyBatis가 처리할 수 있는 형식으로 정의합니다.

Mapper 클래스는 다음과 같은 역할을 합니다:
SQL 쿼리 정의: 각 메소드는 실행할 SQL 쿼리를 정의합니다. 이 쿼리는 일반적으로 Mapper XML 파일에서 정의하고, 메소드 내에서 해당 쿼리를 호출하거나 조작합니다.
매개변수 전달: 메소드의 매개변수는 SQL 쿼리에 필요한 파라미터를 전달하는 역할을 합니다. MyBatis는 이러한 매개변수를 사용하여 동적 SQL 생성 및 실행을 지원합니다.
결과 반환: SQL 쿼리의 실행 결과를 메소드의 반환값으로 받습니다. 반환값은 주로 단일 객체, 리스트 등의 형태로 SQL 결과를 자바 객체로 매핑합니다.

Mapper XML 파일
Mapper XML 파일은 SQL 쿼리를 정의하고 MyBatis의 기능을 활용하여 데이터베이스와 상호작용하는 데 사용됩니다.

Mapper XML 파일의 주요 역할은 다음과 같습니다:
SQL 쿼리 정의: SQL 쿼리를 XML 형식으로 정의하여 저장합니다. 이 파일에서 쿼리는 데이터베이스와의 상호작용을 정의하며, MyBatis는 이 쿼리를 실행합니다.
매개변수 매핑: SQL 쿼리의 매개변수를 Java 객체의 필드에 매핑하거나, 매개변수를 동적으로 생성하기 위한 로직을 포함할 수 있습니다.
결과 매핑: 데이터베이스에서 반환된 결과를 Java 객체로 매핑하여 Mapper 클래스로 반환합니다.
이 과정에서 MyBatis는 ResultSet에서 데이터를 추출하고, 결과를 Mapper 클래스에 맞게 매핑합니다.

동작 원리 및 순서
MyBatis는 다음과 같은 순서로 Mapper 클래스와 Mapper XML 파일을 사용하여 SQL 쿼리를 실행합니다:
Mapper 인터페이스 정의: Mapper 인터페이스에는 데이터베이스와 상호작용할 메소드들이 정의되어 있습니다.
각 메소드는 Mapper XML 파일에서 정의된 SQL 쿼리를 실행하기 위한 지시자 역할을 합니다.
Mapper XML 파일 작성: Mapper XML 파일에는 실제 SQL 쿼리가 정의되어 있습니다. 이 파일에는 SQL 쿼리, 매개변수 매핑, 결과 매핑 등이 포함됩니다.
MyBatis 설정 파일 구성: MyBatis 설정 파일에는 데이터베이스 연결 정보와 Mapper 클래스, Mapper XML 파일의 위치 등을 설정합니다.
이를 통해 MyBatis가 어떤 데이터베이스와 어떤 Mapper 클래스를 사용할지 설정합니다.
실행 시 MyBatis 동작: 애플리케이션에서 Mapper 클래스를 사용하여 SQL 쿼리를 실행하면, MyBatis는 해당 메소드와 연결된 Mapper XML 파일에서 정의된 SQL 쿼리를 찾아 실행합니다.
SQL 실행 및 결과 처리: MyBatis는 SQL 쿼리를 데이터베이스로 전송하고, 데이터베이스에서 반환된 결과를 자바 객체로 매핑하여 반환합니다.
이 과정에서 매개변수 전달, 결과 매핑 등이 수행됩니다.
이와 같은 방식으로 Mapper 클래스와 Mapper XML 파일은 MyBatis를 통해 데이터베이스와 상호작용하여 데이터를 조회, 추가, 수정, 삭제하는 역할을 수행합니다.

-- 14장 화면 개발
URI, URL (식별자들) 을 공유할 때, 혹은 돌아가거나 새로고침 할 때
요즘에는 브라우저에 뒤로가기가 있지만 되돌아 가더라도 데이터를 유지해야 할 필요가 있음
JSP 는 View 역할에만 충실하게
화면에 필요한 데이터 -> PageDTO 사용 (페이지 번호용)

-- 페이지 번호 계산
기본적으로 페이지당 10개, 페이지 번호는 10개를 생각하고 구현해보자
마지막 페이지를 먼저 계산하는게 좋음
EX. 1 부터 10 번째 페이지에 머무르면 리스트는 10까지, 11부터 20번째 페이지에 머무르면 리스트는 20까지 나와야 함
ceil (10번째 페이지 / 페이지 번호 10) * 페이지 번호 10 = 끝페이지 10
ceil (2번째 페이지 / 페이지 번호 10) * 페이지 번호 10 = 끝페이지 10 (ceil 은 소수점 뒤 자리를 무조건 올리기 때문)
ceil (12번째 페이지 / 페이지 번호 10) * 페이지 번호 10 = 끝페이지 20 (ceil 은 소수점 뒤 자리를 무조건 올리기 때문)
여기서 나온 끝페이지 에서 -9 를 하면 페이지 리스트의 첫 페이지인 1 이 나옴
ceil (12번째 페이지 / 페이지 번호 10) * 페이지 번호 10 = 끝페이지 20
여기서 나온 끝페이지 에서 -9 를 하면 페이지 리스트의 첫 페이지인 11 이 나옴

임시로 마지막 페이지를 구한 경우 (10, 20...), 각 페이지당 10개의 데이터를 출력한 경우
실제 데이터의 수는 123개 라고 가정해보자
마지막 페이지를 10 으로 구한 경우 문제 없음
마지막 페이지를 20 으로 구한 경우 13페이지까지만 출력
마지막 페이지를 30 으로 구한 경우 21페이지부터 나와야 하기 때문에 계산이 잘못됨
즉 13페이지의 일부까지는 정상 출력, 14페이지부터는 비어있음
임시 페이지 수를 구하고 실제 데이터 건수를 이용해서 계산을 다시 한번 해야함
PageDTO 는 컨트롤러에서 처리하기 위해 Model 에 담아야 하고 totalCount 를 구하는 작업이 추가되어야 함

-- 전체 데이터 개수 구하기 (totalAmount)
화면에서 마지막 페이지 번호를 구하기 위해 필요함
PageDTO 라는 객체를 만들기 위해서는 전체 데이터 개수가 필요한데, Service -> Mapper 호출해서 구해야 함
BoardMapper 인터페이스에 먼저 선언할 것!! 그 후에는 xml 에 구현
데이터의 개수는 WHERE 조건 (검색 조건) 이 들어올 때 같이 처리해야 함
list 와 동일하게 만들어야 Criteria 파라미터를 가져다 쓸 수 있음

-- 화면에 이벤트 걸기 (JS 이용)
JQuery 를 사용할 때는 이벤트를 한번에 여러개를 이용할 수 있어서 단순하지만 순수한 JS 에서는 불가능하므로 처리 방법을 알아보자
한 페이지에서 이벤트를 많이 거는 방법은 효율적이지 못함
li 말고 상위인 ul 에 이벤트를 주어 li 전부 이벤트가 걸리게 설정 -> li 의 실제 값(e.target) 을 알아야 함
href 에 연결된 pageNum 을 알아야 함 -> window.location 을 이용해 변경해줄 수 있음

----- 0712 깃허브 연동
1. 깃 초기화
git init

2. 원격 저장소 설정
git remote add origin [저장 url]

3. 깃허브 저장소 클론
git clone [저장 url]

4. 변경사항 커밋 푸시
스테이징
git add .
커밋
git commit -m "커밋 메시지"
푸시
git push origin [브랜치 이름]

5. 변경사항 가져오기
git pull origin [브랜치 이름]

6. 자동 동기화 설정 (옵션)

-- 뒤로가기 이동
컨트롤러에서 기존에는 번호만 받아도 됐지만 이제는 검색 조건인 Criteria 도 있어야 함

-- 조회, 수정시 목록화면 이벤트 처리
조회 및 수정에서 목록으로 돌아갈 때 Criteria 에서 pageNum 을 받아야 다시 리스트로 갈 때 원래 조회하던 페이지 번호로 갈 수 있음

-- 검색 처리
검색을 할 때는 조건문이 붙음
동적으로 SQL Select 를 만들어야 할 때가 많음
제목 t, 내용 c, 작성자 w 인 경우 이 조합에 대해 미리 조건을 만들어둬야 함
미리 염두해두고 정적으로 모두 만들 수 없음 (조건이 늘어날수록 조합의 수는 팩토리얼이 되기 때문, 너무 많다)
Mybatis 에서는 Dynamic SQL 을 지원함 (https://mybatis.org/mybatis-3/ko/dynamic-sql.html)
SQL 문의 재사용을 위해 BoardMapper.xml 에서 SQL PreparedStatement 생성 시 <sql> 태그 활용하기

-- 검색 화면 처리
1. Controller 검증 (GET 방식) -> 브라우저에서 검색
2. List.jsp 처리

검색창, 조건창, 버튼 등
버튼을 클릭했을 때 작동하는 JS -> actionForm 에 원하는 값 (조건 등) 을 submit 하는 것
화면에서 출력될 때 기존에 검색하던 조건이 이미 선택이 완료된 상태로 출력될 수 있게
검색 버튼을 클릭한다 -> 검색 조건을 유지한 상태로 1 페이지로 간다 (조건에 맞춘 새로운 pageNum 으로 정렬되므로)
현재 모든 이동은 actionForm 을 이용하고 있음, 새로운 Form 을 만들어서 이동할 수 도 있음

------------ 중요
list.jsp 에서 검색 옵션을 추가할때 만든 Search 버튼에 searchBtn 이라는 클래스를 부여함
JS 에서 searchBtn 클릭 시 액션을 추가하고 있는데 (페이지는 1페이지 이동하면서 검색 조건 GET 으로 받아 유지)
querySelector 에서 .(점)이 빠지면 클래스로 선택된 요소를 찾을 수 없음.
querySelector 는 CSS 선택자를 사용하여 요소를 선택하는 메서드이며, 클래스를 선택할 때는 점(.)을 사용해야 함.
코드에서 querySelector(".searchBtn")은 .searchBtn 클래스를 가진 요소를 찾는 것.
이 코드에서 .을 빼면 CSS 클래스 선택자가 제거되어 다른 형태의 선택자로 해석될 수 있음.
일반적으로 클래스를 선택할 때는 점(.)을 사용하는 것이 CSS 선택자의 규칙임

-- 검색 화면 처리 2
지금까지는 List 에서만 검색이 유지되었음
조회, 수정의 화면에서도 다시 목록으로 돌아갈 때 검색 조건을 유지해야 할 필요가 있음
현재 변하는 값 등은 Criteria 에 들어있고 Model 에 담겨서 전달하고 있음 -> 간단하게 출력할 수 있는 구조
객체로 만들어서 전달하는것이 좋음

---------- Part 4 댓글과 Rest
Ajax 개념 설명

예전에는 브라우저가 서버에 보내고 서버에서 결과를 만들어서 브라우저로 리턴함 (JSP 같은것)
JSP 는 자바코드로 바뀌기 때문에 자바의 실행 결과를 브라우저로 보냈음
HTML5 에서는 브라우저가 많은 일을 할 수 있도록 플랫폼을 만드는게 목적 -> WEB APP 의 정의 (더이상 page, site 가 아님)

-- Ajax (Asynchronous JavaScript and XML)
Ajax 는 비동기적으로 웹 페이지의 일부를 업데이트하고 서버와 데이터를 교환하기 위한 기술.
기본적으로 XMLHttpRequest 객체를 사용하여 데이터를 서버로부터 가져오거나 서버에 데이터를 보낼 수 있음.
주로 웹 페이지에서 사용자 경험을 향상시키기 위해 동적으로 데이터를 로드하거나 업데이트하는 데 활용됩니다.
사용 예시: 실시간 데이터 업데이트, 자동 완성 기능 등 웹 페이지의 동적 기능 구현 등

-- REST API (Representational State Transfer API)
기능 및 목적:
REST API는 Representational State Transfer의 약자로, 웹 서비스 간의 통신을 위한 아키텍처 스타일을 의미.
REST는 자원(Resource)을 URL로 표현하고, HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 해당 자원을 조작하는 방식.
목적은 네트워크 상에서 자원을 정의하고, 자원에 대한 주소를 지정하는 것.
사용 예시: 다른 서비스나 애플리케이션과 데이터를 공유하거나 통합할 때 사용

ex. URL/URI 는 경로(식별자) 의 역할을 함 (불변, 메타정보, 택 같은 개념) -> 이 대상들을 Resource 라고 부름
CRUD 작업을 할 때 예전에는 QueryString (파라미터) 로 결정됨 -> GET/POST 메서드
GET/POST/PUT/DELETE 등등 다양한 메서드를 사용하기 위한 것이 REST
스프링에서는 RESTController 라이브러리를 제공함 -> JSON, REST 처리할 수 있음


Jackson Databind 라이브러리가 있어야 Spring MVC 에서는 나오는 데이터를 기본적으로 JSON 처리를 함

GSON -> 직접 JSON 을 가공할 때 사용
자바의 오브젝트를 이용해 JSON 데이터로 변환시키는 구글의 라이브러리

@RestController 는 객체를 반환하는 것이 좋음
만약 String 리턴이라면 -> Response 의 Content-Type 이 text/html 로 들어가게 됨
원하는 형태의 데이터로 생성이 되지 않을 수 있음

-- 댓글 API 설계
댓글은 리소스임
API 는 어떤 방식으로 호출할지를 고름 -> GET/POST 등 + 데이터를 어떻게 보낼지 설계 -> 결과는 무엇이 나갈지 설계
리소스의 정의, 메서드의 종류, 어떤 파라미터, 결과데이터 의 도표화 필요 (규칙이 존재하는것은 아님)
등록 -> /reply (매핑), 메서드 -> POST, 데이터 -> JSON, 결과 -> Ajax (브라우저에서 REST API 호출 시 많이 사용)
고유한 식별자를 사용하는 조회, 수정, 삭제
조회 -> /reply/{rno}, 메서드 -> GET, 데이터 -> 이미 {rno}가 매핑되어 필요없음, 결과 -> {댓글 데이터}
수정 -> /reply/{rno}, 메서드 -> PUT, 데이터 -> {댓글 데이터}, 결과 -> {result:success} 같은 데이터 (성공하는 것을 기준으로 설계)
삭제 -> /reply/{rno}, 메서드 -> DELETE, 데이터 -> 데이터 전달이 불가, 결과 -> {result:success} 같은 데이터
댓글이 달린 원본 글이 필요하지만 페이지 번호는 변화할 수 있으므로 고유한 식별자가 아닌 경우
GET 방식에서는 추가적인 데이터의 전달이 힘듦. Criteria 의 pageNum 을 쿼리스트링으로 사용할 수 있음
목록 -> /reply/list/{bno}/{Criteria 의 pageNum}, 결과 -> 목록 데이터 배열 (JSON)

-- 댓글 데이터베이스 설계 및 영속 영역 개발
데이터베이스에서 관계를 볼 때는 PK 보다 FK를 기준으로 보는것이 맞음
tbl_board 에는 bno 가 있음 (PK)
tbl_reply 에는 단독으로 CRUD 가 가능할 수 있음, rno 를 가짐 (PK), rno 는 bno (FK) 에 반드시 속함
tbl_reply 에는 replyText, replier, replyDate, replyUpdate, replyDelete 등등이 있을 수 있음

-- 새로 매핑하는 순서
ReplyVO 같은 타입을 먼저 만들고 Mapper 인터페이스를 작성한 후에 XML 을 작성하는 것이 좋음

-- 댓글 조회, 수정, 삭제
댓글은 목록 단위로 나오는 경우가 많음
rno 컬럼 (PK) 중심으로 개발할 것
tbl_reply 에서 rno 는 PK, bno 는 FK 인데 게시물 당 댓글 수를 알아야 함
게시글 당 댓글을 전체조회 (full-scan) 을 해야 할 때 댓글이 많다면 성능 차이가 남 -> MariaDB 에서 index 를 잡아줘야 함

-- 댓글 목록 개발
특정한 게시글의 댓글을 가져올 때 페이징을 새로 해줘야 함
순번의 정렬 순서 (댓글은 낮은 번호가 위로 가게 됨 desc, 게시글은 최신이 위로 감 asc)
페이징 처리는 Criteria 사용해서 처리 가능

-- 댓글 Service, Controller 개발
ReplyService 에는
댓글 등록, 댓글 조회, 댓글 수정, 댓글 삭제, 댓글들 조회, 특정 게시글의 댓글 수 조회 기능이 필요함

ReplyController 는 REST-Controller 로 설계되어야 함 (JSON 데이터를 다루도록)
작업, URI, Method (전송 방식), 기타 (결과) 로 구성이 되어야 함
작업 -> 등록, 조회, 삭제, 수정, 댓글목록
URI -> /register, /{rno}, /{rno}, /{rno}, /list/{bno} ({cri.pageNum}{cri.amount} 추가 가능)
Method -> POST, GET, DELETE, PUT, GET
결과(예제) -> JSON(ThymeLeaf), JSON, MAP(JSON), JSON

-- 댓글 추가 @RequestBody
댓글을 추가할 때는 JSON 형태로 전송하게 되고 ReplyVO 로 수집을 하게 됨
@RequestBody -> JSON 데이터를 자바의 객체로 바꿔주는 역할을 하는 어노테이션

------------------ 중요
브라우저에 직접 uri 를 입력하는 경우 GET 방식만 처리할 수 있음
그렇기 때문에 GET 을 제외한 POST, DELETE, PUT 등의 메서드는 HTML 의 폼, JS, Postman 등으로 요청할 수 있음

-- Axios 와 Ajax
JSP 파일은 JS 를 받아 CRUD 를 처리함
조회화면에서 댓글을 처리하기 때문에 최근에는 조회/수정 화면이 분리되고 있음
Ajax 를 이용하기 위해 Axios 라이브러리를 사용함
요즘에는 jQuery (JS 문법 통일용) 을 쓰지 않기 때문에 Ajax/Axios 로 진행함
과거에는 새로운 데이터를 받아오려면 브라우저를 지우고 서버에서 가져온 데이터를 뿌리는 형태 (스케치북 처럼)
Ajax 를 사용하면 브라우저를 지우지 않고 내부에서 서버와 비동기 통신을 함
비동기 통신이란? 따로 노는 통신 (자동완성, 구글 지도 등)
Axios 는 JSON 데이터를 기본으로 주고받음 (JS 라이브러리)
Read.jsp Script 에 Axios 추가 (JS 는 처음에 페이지에 넣고 개발한 후, 나중에 뜯어내는게 좋음)
비동기와 동기의 처리 제대로 알 것!

-- 부트스트랩에서 형식 찾고 댓글 목록 페이지 구현하기
getList async 함수에서는 pageNum 과 amount 의 값을 정의하고
await 과 쌍을 이루어 /reply/list/\${boardBno} 를 호출 했을 때
JSON 타입 (axios 를 사용했으므로) 으로 PageDTO, ReplyList 를 받아 res 라는 변수에 저장
이때 axios 가 GET 방식으로 /reply/list/\${boardBno} 뒤에 "?" 와 각각의 params 안의 데이터를 자동으로 넣어줌
콘솔을 찍어보면 PageDTO 와 ReplyList 는 data 안에 들어있으므로 res.data 로 접근
PageDTO 에는 Cri, endPage 등등, ReplyList 에는 rno, bno, replyText, replyer 등이 있음
printReplyList 를 먼저 정의하고 파라미터로 pageDTO, replyList 를 받음
.replyList 클래스를 replyUL 에 담고 내부의 HTML 문을 초기화 시킴 ("" 사용)
새로운 HTML 문을 담을 str 변수 선언
반복문을 돌면서 replyList 의 내용(객체 수) 만큼 HTML 문을 str 변수에 더하면서 반복
replyUL 의 내부 HTML 문을 str 변수로 대체

-- 댓글 페이징 처리
특정 게시글을 조회하면 게시글에 대한 서버 호출이 이루어짐 -> JSP 가 완성되고 결과물을 HTML, JS 를 보내고 브라우저가 받아서 출력함
JS가 실행할 때 Axios 호출이 있으니까 /reply/list/bno(특정 게시물)?pageNum=...&amount=... (Criteria 정보) 에 가서 QueryString 전달
저 URI 에서 JSON 데이터를 Axios 가 가져다가 화면에 댓글 목록을 만들면서 출력 (Dynamic HTML)
댓글의 페이지 번호도 추가해야함
1. 리스트 구현에 필요한 HTML 코드 넣기 (BootStrap) -> 댓글 페이지 구현 div 안에 넣기
2. 위에 구현한 HTML 코드의 .pagination 클래스를 pageUL 변수에 담기
3. pageDTO (axios 가 받아주는 JSON, getList 함수에서 정의했음, printReplyList 의 파라미터) 에서 필요한 데이터들을 변수로 추출
4. pageDTO 가 가져오는 cri 안의 pageNum 도 변수로 받기
5. HTML 문을 담을 변수 선언 (내용은 '')
6. startPage 를 선언했으므로 startPage 부터 endPage 까지 반복문을 돌며 li 태그 작성
7. li 클래스 안에 active 속성을 현재 페이지 에서만 넣을 수 있도록 삼항연산자 사용 (JSP 안에서 JS 사용시 Java 와 혼동 되지 않도록 \${} 사용)
8. 이전, 다음 pagination 처리를 위해 prev 는 for 문 전에 작성, next 는 for 다음에

-- 댓글 페이지 이벤트 처리
댓글 클릭 시에 동적으로 변할 수 있는 이벤트가 있어야 함
JS 를 통해 만들어지는 HTML 에 처음부터 이벤트를 걸면 먹히지 않음!!
기존에 존재하는 Element 에 동적 이벤트를 걸어야 함 -> 이벤트의 실제 내용물을 찾아갈 수 있도록
href 값에 startPage-1, endPage+1 을 할당하고 클릭 시 기본동작 막아야 함!!
pageUl 에 addEventListener 를 걸고 click 이벤트 걸기,
이벤트 처리 함수, 핸들러 함수 만들기, 버블링 false, 기본동작 막기
이벤트의 타겟을 target 변수에 담고 타겟에 getAttribute 로 href 값 얻어오기

-- 댓글 등록 처리
MODAL 창을 이용해서 replyText, replyer 입력을 할 수 있게 설계
버튼을 이용해서 저장 -> POST 방식으로 Ajax 를 전달
/reply/register URI 이용 -> n 번 댓글이 오도록 설계
댓글이 달리면 기존의 댓글 목록이 안나옴 -> 갱신하는 이벤트도 넣기
현재 댓글은 10개씩 출력하는데 시간의 순서대로 출력하고 있음 -> 새 댓글은 뒤로 밀려 보이지 않는 문제 해결
list.jsp 에서 bootstrap 하위 Modal 을 사용했던 것처럼 read.jsp 에서 사용
1. bootstrap.Modal 사용해서 상수로 받기
2. Modal HTML 안의 input name 들 상수로 받기
3. 버튼 설계 -> 버튼을 눌렀을 때 등록이 될 수 있도록 Ajax 작업 (getList 에서 async 로 함수 작업하듯)
3.1 registerReply async 함수는 axios.post 방식으로 전달 -> 상수로 받음

Axios 는 기본적으로 JS 객체를 JSON 을 주고받으니까 파라미터로 전달되는 replyObj 는 객체로 만들어짐
replyObj 는 replyTextInput 과 replyerInput 의 value 로 이루어진 객체 (getList() 에서 정의)
await 처리 했으므로 순차적으로 코드 짤 수 있음
댓글은 항상 특정 bno 에 맞춰 들어가므로 bno 값도 잊지 말고 넣기!!
이 과정들은 비동기 처리 -> 이 과정이 다 끝나면 Modal 창을 가리는 작업(hide) 를 하고싶음
Modal 창을 닫는 함수를 파라미터로 전달하거나 (CallBack)
모든 Async (비동기) 함수는 반환해 줄 수 있는게 없어서 리턴 타입이 Promise 타입으로 나오는데 then() 을 이용할 수도 있음
registerReply 함수는 비동기 -> 리턴 값이 없으므로 result 는 undefined 가 나옴 -> Modal 닫기만 실행

지금 추가된 댓글들은 새로고침 전에는 보이지 않음 -> 새로 목록데이터를 가져오는 작업을 넣어야 함
목록데이터를 가져와도 댓글이 1페이지에 있지 않다면 문제가 생김

댓글을 추가하면 새로운 댓글의 번호가 나옴 -> DB 에서 몇개의 댓글이 있는지 받아오기 -> 댓글 수에 맞는 페이지 조회 구현
새로운 댓글이 달려도 또 다른 댓글이 달릴 수 있음 -> 동시성 처리에 유의

Mapper (Repository) 부터 작성 시작 -> ReplyService 에 기능 구현 -> Controller 에서 설정 (결과 값을 보내는 기능까지 구현!)
이 기능으로 댓글의 갯수를 read.jsp 의 registerReply 에서 페이징 처리 가능하도록

-- 댓글 조회와 수정화면
댓글에서는 페이징 처리를 했음 -> 댓글 조회를 하게 되면 그 사이에 댓글이 수정될 수 있음
조회가 될 때에도 서버에서 호출하고 새로운 댓글을 조회해야 함 (요즘에는 무한 스크롤도 이용함)
수정과 삭제를 Modal 창에서 하고 있는데 결과가 반영되는것을 확인해야 함 (페이지 확인 등)

모달 창 하나 더 추가
특정한 댓글을 클릭 (동적임, 원래 존재하는 바깥쪽 replyUL 에 이벤트를 걸고 가져오기)
-> replyRegister 에서 Ajax 를 async 로 쓰면 동기화 처리가 되어 데이터를 나중에 가져오기 때문에 나중에 오는 내용은 이벤트가 걸리지 않음
printReplyList 가 아니라 그 상위인 replyUL 에 이벤트 걸어야 이벤트를 걸고 불러올 수 있음
const target = e.target -> 이벤트가 가르키는 타겟은 replyUL
pageUL 의 번호도 받기 -> 이 모든 작업이 서버에서 데이터를 받아서 Modal 창에 데이터를 전달하기 위한 작업

-- 댓글 화면에서 모달 출력
reply 데이터를 가져왔으면 리턴을 함
rno 를 파라미터로 받은 getReply 비동기 함수가 axios 를 이용해 JSON 타입으로 /reply/${rno} 를 GET 방식으로 처리함
async 함수의 결과 값은 항상 Promise 타입이다

-- 모달 화면에서 수정, 삭제 버튼 만들기
삭제는 1페이지를 조회하는 것으로 돌아가면 됨
ReplyController 의 delete 메서드에서는 "Result Delete" 라는 이름으로 결과값이 나옴
read.jsp 에는 수많은 JS 코드가 있는데 따로 추출한 후 <script src="../경로.js"></script> <!-- 분리한 JavaScript 파일 경로 --> 등으로 빼는게 좋음

------------ Part 5
-- AOP / Transaction 설정
AOP -> Aspect Oriented Program
Aspect -> 관점
코드를 짜다 보면 반복적으로 짜게 됨 -> 이것을 해결하기 위해 패턴을 사용함
AOP 는 이런 것들의 미리 순서나 방법을 정해두는 것
자바에서는 AOP 를 구현할 때 2가지 방법이 있음
1. Java Proxy, 2. CGLIB -> Spring Boot 2.4 부터는 CGLIB 가 기본으로 포함

-- AOP 설명
왜 쓰는가? -> 공통 코드가 사라짐 (cross concern)
어떻게 적용하는가? -> Spring AOP, CGLIB, Aspectj 같은 라이브러리 사용 (수업에서는 AspectJ 사용 -> Runtime, Weaver)
어떻게 쓰는가? -> 로그, 버그 검증시 -> Transaction 으로 연결됨
Spring AOP, AspectJ Runtime, AspectJ Weaver 추가 (AspectJ 는 runtimeOnly -> implementation 으로 변경하여 추가)

-- AOP 용어
AOP 에서의 Aspect 는 기능별로 프로그램을 세분화 시키는 것 (관점)
AspectJ -> 내가 없는 코드가 붙는 것
내가 만든 코드 -> target 이라 부름 (타겟)
target 에 원하는 기능이 있음 -> Aspect (추상)
Aspect 를 구현하는 코드를 Advice 라고 함 (구현 코드)
타겟에 advice 를 적용하려면? 적용에 대한 설정 -> PointCut 포인트컷 (설정)
타겟에 Advice 를 넣어 PointCut 설정으로 만들어지는 것 -> Proxy (프록시)

타겟을 만들고 원하는 Advice (구현 코드) 를 만듦 -> 포인트컷은 설정 (만드는것은 아님) -> 프록시는 자동으로 만들어짐 (AutoProxy)

-- AOP 개발 순서
1. Target 개발 => 원하는 로직 개발
2. 적용할 Aspect 고민 (1번과 2번은 순서가 바뀔 수도 있음) -> 클래스 형태의 Advice 개발 -> 설정 작업 (포인트 컷)
3. 스프링 설정 변경 -> 자동으로 (AutoProxy) 프록시 생성
3.1 자동으로 프록시가 생성되면 자동으로 만들어지는 클래스의 이름이 다를 수 있음 (예전에는 그 이유 때문에 인터페이스로 많이 씀)
